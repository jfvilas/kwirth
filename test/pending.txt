******************ERRORES
RFM
cuando cambiamos de pantalla en magnify (o lo que sea) y cambian las columnas, hay que resetear los widths de las columnas

MAGNIFY FRONT
reconnect  NO VA!!!!
    hay que revisar el reconnect del node y el reconnect del front
decimales en cpu del pod
navigate (onlink) a un CRDi externo
colores en las conditions de los nodes


PV: secrets
  csi:
    driver: file.csi.azure.com
    nodeStageSecretRef:
      name: nextbpm-azure-secret
      namespace: psd-nextbpm


crd instances duplicates
en los templates no usar inCluster , usar $cluster  +++test

ELECTRON
revisar el cambio o salida de cluster: parar las cosas antes de entrar en el otro
    en el backend, parar las cosas si se pierde la comnicacion con el front??
ocultar en el front lo que es de kwirth y no de magnify (to be lens-like)
    eliminar menus  +++TEST AL FINAL
    ocultar las partes del menu que no aplican, como gestion de usuarios o api keys
implementar un read/store equivalente a los configmaps (para almacenamiento en local, asi popdemos gaurdar prefs o settings sin enviar nada al backend)
revisar funcionamiento de conectar a cluster remoto
a침adir un color de si esta o no accesible el cluster (testear con una llamada al api de k8)
conexion a cluster remoto

MAGNIFY BACK

KWIRTH FRONT



*******************MEJORAS


FILEMAN
cuando se lanza una peticion deberia aparecer un backdrop en filelist indicando que estamos esperando

MAGNIFY FRONT
validation rules
    *** obtener un resumen da validaciones para mostrar en el magnify overview
en la vista de lista, acciones multi item (metrics, logs...)
contentexternal
    configuracion
    chartmenu
details
    +++ cm/secret: textarea, > tama침o inicial fijo (no todo el contenido)
    +++ servaccnt: tokens ifpresent
    events > revisar orden 23h59m, y revisar orden si no hay fechahora (en blanco) +++TEST
游눘游눘游눘 portforward con smart proxy
    running, just manage to detect rootpath in order to enable/disable forwarding
    portforward con electorn


KWIRTH
  a침adir logging selectivo en el backend: SEC, METRICS, CHANNEL...., para poder ver solo los mensaje squ enos intenresan
  en los last tabs deberiamos poder saber a que nos vamos a conectar antes de conectarnos (un tooltip o asin)
  mostrar el nombre del cluster en la appbar


    

*********V2*********
KWIRTH
log de jobs: revisar "started &&"
channel metrics: a침adir metricas sinteticas: numero de pods en nodo, percentage de pods
a침adir gestion centralizada de timeouts e intervasl en front y en back [codigo mas abajo]
a침adir info del cluster al que se est alogando el usuario en el card de login

MAGNIFY FRONT
    improve DetailsObject
        always use rootObj, and just change the path, so trace-back can be used ofr detecting data changed origin
    zona de avisos del cluster (implementar en filemanager, una campana)
    busquedas: buscar en los CRD y en los CRDi
    mejorar el resize column

RFM
    en los fileitem, cuando le fila es muy alta, el nombre del fileitem se esta alineando arriab, y deberia ir al centro

KWIRTH
crear un permiso para indicar que cosas del front puede ver el usuario
crear un setting del usuario tipo "autoexec.bat"
mover los settigns de trivy a trivy


==============================================================================


global.activeTimers = new Map();

// --- Interceptar INTERVALOS ---
const originalSetInterval = global.setInterval;
const originalClearInterval = global.clearInterval;

global.setInterval = (handler, timeout, ...args) => {
  const id = originalSetInterval(handler, timeout, ...args);
  global.activeTimers.set(id, {
    type: 'Interval',
    createdAt: new Date().toLocaleTimeString(),
    ms: timeout
  });
  return id;
};

global.clearInterval = (id) => {
  global.activeTimers.delete(id);
  originalClearInterval(id);
};

// --- Interceptar TIMEOUTS ---
const originalSetTimeout = global.setTimeout;
const originalClearTimeout = global.clearTimeout;

global.setTimeout = (handler, timeout, ...args) => {
  const id = originalSetTimeout((...innerArgs) => {
    // Cuando el timeout se ejecuta, se borra solo de la lista
    global.activeTimers.delete(id);
    handler(...innerArgs);
  }, timeout, ...args);

  global.activeTimers.set(id, {
    type: 'Timeout',
    createdAt: new Date().toLocaleTimeString(),
    ms: timeout
  });
  return id;
};

global.clearTimeout = (id) => {
  global.activeTimers.delete(id);
  originalClearTimeout(id);
};
